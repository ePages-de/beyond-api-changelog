"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const diff_classifier_1 = require("./spec-differ/diff-classifier");
const diff_finder_1 = require("./spec-differ/diff-finder");
const spec_deserialiser_1 = require("./spec-differ/spec-deserialiser");
const spec_parser_1 = require("./spec-parser");
class SpecDiffer {
    static diffSpecs(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedSpecs = yield this.toParsedSpecs(options);
            const differences = yield diff_finder_1.DiffFinder.findDifferences(parsedSpecs);
            const classifiedDifferences = diff_classifier_1.DiffClassifier.classifyDifferences(differences);
            return this.createDiffOutcome(classifiedDifferences);
        });
    }
    static createDiffOutcome(classifiedDifferences) {
        const breakingDifferencesFound = classifiedDifferences.breakingDifferences.length > 0;
        return breakingDifferencesFound
            ? {
                breakingDifferences: classifiedDifferences.breakingDifferences,
                breakingDifferencesFound,
                nonBreakingDifferences: classifiedDifferences.nonBreakingDifferences,
                unclassifiedDifferences: classifiedDifferences.unclassifiedDifferences
            }
            : {
                breakingDifferencesFound,
                nonBreakingDifferences: classifiedDifferences.nonBreakingDifferences,
                unclassifiedDifferences: classifiedDifferences.unclassifiedDifferences
            };
    }
    static toParsedSpecs(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const [sourceSpec, destinationSpec] = yield Promise.all([
                this.toParsedSpec(options.sourceSpec),
                this.toParsedSpec(options.destinationSpec)
            ]);
            return { sourceSpec, destinationSpec };
        });
    }
    static toParsedSpec(serialisedSpec) {
        const deserialisedContent = spec_deserialiser_1.SpecDeserialiser.load(serialisedSpec);
        return spec_parser_1.SpecParser.parse({
            content: deserialisedContent,
            location: serialisedSpec.location,
            unverifiedFormat: serialisedSpec.format
        });
    }
}
exports.SpecDiffer = SpecDiffer;
