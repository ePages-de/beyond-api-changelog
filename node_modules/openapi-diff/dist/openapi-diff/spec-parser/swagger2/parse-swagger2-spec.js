"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const parse_x_properties_1 = require("../common/parse-x-properties");
const path_builder_1 = require("../common/path-builder");
const typeCheckedSwagger2Methods = {
    delete: undefined,
    get: undefined,
    head: undefined,
    options: undefined,
    patch: undefined,
    post: undefined,
    put: undefined
};
const isSwagger2Method = (propertyName) => Object.keys(typeCheckedSwagger2Methods).indexOf(propertyName) >= 0;
const findBodyParameterAndIndex = (parameters) => {
    let bodyParameterIndex = -1;
    const bodyParameter = parameters.find((parameter, index) => {
        const isBody = parameter.in === 'body';
        bodyParameterIndex = index;
        return isBody;
    });
    return { bodyParameter, index: bodyParameterIndex };
};
function toParsedRequestBody(bodyParameter, pathBuilder) {
    return {
        jsonSchema: {
            originalPath: pathBuilder.withChild('schema').build(),
            value: bodyParameter.schema
        },
        originalValue: {
            originalPath: pathBuilder.build(),
            value: bodyParameter
        }
    };
}
const parseBodyParameter = (parameters, pathBuilder) => {
    const { bodyParameter, index } = findBodyParameterAndIndex(parameters);
    if (bodyParameter) {
        return toParsedRequestBody(bodyParameter, pathBuilder.withChild(`${index}`));
    }
    return {
        originalValue: {
            originalPath: pathBuilder.build(),
            value: undefined
        }
    };
};
const parseResponses = (responses, pathBuilder) => {
    return Object.keys(responses).reduce((accumulator, statusCode) => {
        const originalPath = pathBuilder.withChild(statusCode);
        accumulator[statusCode] = {
            originalValue: {
                originalPath: originalPath.build(),
                value: responses[statusCode]
            }
        };
        return accumulator;
    }, {});
};
const parseOperations = (pathItemObject, pathBuilder) => {
    return Object.keys(pathItemObject)
        .filter(isSwagger2Method)
        .reduce((accumulator, method) => {
        const operationObject = pathItemObject[method];
        const operationPath = pathBuilder.withChild(method);
        const parametersPath = operationPath.withChild('parameters');
        const parameters = operationObject
            ? operationObject.parameters || []
            : [];
        const requestBody = parseBodyParameter(parameters, parametersPath);
        const responsesPath = operationPath.withChild('responses');
        const responses = operationObject
            ? parseResponses(operationObject.responses, responsesPath)
            : {};
        accumulator[method] = {
            originalValue: {
                originalPath: operationPath.build(),
                value: pathItemObject[method]
            },
            requestBody,
            responses
        };
        return accumulator;
    }, {});
};
const parsePaths = (paths, pathBuilder) => Object.keys(paths).reduce((accumulator, pathName) => {
    const pathItemObject = paths[pathName];
    const originalPath = pathBuilder.withChild(pathName);
    accumulator[pathName] = {
        operations: parseOperations(pathItemObject, originalPath),
        originalValue: {
            originalPath: originalPath.build(),
            value: paths[pathName]
        },
        pathName
    };
    return accumulator;
}, {});
exports.parseSwagger2Spec = (swagger2Spec) => {
    const pathBuilder = path_builder_1.PathBuilder.createRootPathBuilder();
    return {
        format: 'swagger2',
        paths: parsePaths(swagger2Spec.paths, pathBuilder.withChild('paths')),
        xProperties: parse_x_properties_1.parseXPropertiesInObject(swagger2Spec, pathBuilder)
    };
};
